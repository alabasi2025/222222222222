import { Router } from 'express';
import { db } from '../db/index';
import { paymentVouchers, paymentVoucherOperations, cashBoxes, banksWallets, accounts, entities } from '../db/schema';
import { eq, desc, and, sql, inArray } from 'drizzle-orm';
import { validate, paymentVoucherSchema } from '../validation';

const router = Router();

// ===== دالة مساعدة لجلب السندات مع البيانات المرتبطة بدون N+1 =====
async function getVouchersWithRelations(vouchers: any[]) {
  if (vouchers.length === 0) return [];

  const voucherIds = vouchers.map(v => v.id);
  const cashBoxIds = [...new Set(vouchers.map(v => v.cashBoxId).filter(Boolean))];
  const bankWalletIds = [...new Set(vouchers.map(v => v.bankWalletId).filter(Boolean))];

  // جلب جميع العمليات دفعة واحدة
  const allOperations = await db.select()
    .from(paymentVoucherOperations)
    .where(inArray(paymentVoucherOperations.voucherId, voucherIds));

  // جلب جميع الحسابات المرتبطة دفعة واحدة
  const allAccountIds = [...new Set([
    ...allOperations.map(op => op.chartAccountId),
    ...allOperations.map(op => op.analyticalAccountId).filter(Boolean),
  ] as string[])];

  const allAccounts = allAccountIds.length > 0
    ? await db.select().from(accounts).where(inArray(accounts.id, allAccountIds))
    : [];

  // جلب الصناديق والبنوك دفعة واحدة
  const allCashBoxes = cashBoxIds.length > 0
    ? await db.select().from(cashBoxes).where(inArray(cashBoxes.id, cashBoxIds))
    : [];

  const allBankWallets = bankWalletIds.length > 0
    ? await db.select().from(banksWallets).where(inArray(banksWallets.id, bankWalletIds))
    : [];

  // بناء خرائط البحث
  const accountsMap = new Map(allAccounts.map(a => [a.id, a]));
  const cashBoxesMap = new Map(allCashBoxes.map(c => [c.id, c]));
  const bankWalletsMap = new Map(allBankWallets.map(b => [b.id, b]));

  return vouchers.map(voucher => {
    const operations = allOperations
      .filter(op => op.voucherId === voucher.id)
      .map(op => ({
        ...op,
        chartAccount: accountsMap.get(op.chartAccountId) || null,
        analyticalAccount: op.analyticalAccountId ? accountsMap.get(op.analyticalAccountId) || null : null,
      }));

    return {
      ...voucher,
      operations,
      cashBox: voucher.cashBoxId ? cashBoxesMap.get(voucher.cashBoxId) || null : null,
      bankWallet: voucher.bankWalletId ? bankWalletsMap.get(voucher.bankWalletId) || null : null,
    };
  });
}

// Get all payment vouchers with pagination
router.get('/', async (req, res) => {
  try {
    const { entityId, type, page = '1', limit = '50' } = req.query;
    const pageNum = Math.max(1, parseInt(page as string) || 1);
    const limitNum = Math.min(200, Math.max(1, parseInt(limit as string) || 50));
    const offset = (pageNum - 1) * limitNum;

    // Build where conditions
    const conditions = [];
    if (entityId) conditions.push(eq(paymentVouchers.entityId, entityId as string));
    if (type) conditions.push(eq(paymentVouchers.type, type as string));

    const whereClause = conditions.length > 0 ? and(...conditions) : undefined;

    const countResult = await db.select({ count: sql<number>`count(*)` })
      .from(paymentVouchers)
      .where(whereClause);
    const total = Number(countResult[0]?.count || 0);

    const vouchers = await db.select()
      .from(paymentVouchers)
      .where(whereClause)
      .orderBy(desc(paymentVouchers.date))
      .limit(limitNum)
      .offset(offset);

    const vouchersWithRelations = await getVouchersWithRelations(vouchers);

    res.json({
      data: vouchersWithRelations,
      pagination: { page: pageNum, limit: limitNum, total, totalPages: Math.ceil(total / limitNum) },
    });
  } catch (error: any) {
    console.error('Error fetching payment vouchers:', error);
    res.status(500).json({ error: 'Failed to fetch payment vouchers' });
  }
});

// Get payment voucher by ID
router.get('/:id', async (req, res) => {
  try {
    const voucher = await db.select()
      .from(paymentVouchers)
      .where(eq(paymentVouchers.id, req.params.id))
      .limit(1);

    if (voucher.length === 0) {
      return res.status(404).json({ error: 'Payment voucher not found' });
    }

    const result = await getVouchersWithRelations(voucher);
    res.json(result[0]);
  } catch (error: any) {
    console.error('Error fetching payment voucher:', error);
    res.status(500).json({ error: 'Failed to fetch payment voucher' });
  }
});

// Create payment voucher with validation
router.post('/', validate(paymentVoucherSchema), async (req, res) => {
  try {
    const {
      entityId, type, cashBoxId, bankWalletId, date, currency,
      exchangeRate, totalAmount, reference, operations, createdBy,
    } = req.body;

    let newVoucher: any;

    await db.transaction(async (tx) => {
      // Create voucher (ID auto-generated by schema)
      const [voucher] = await tx.insert(paymentVouchers).values({
        entityId,
        type,
        cashBoxId: cashBoxId || null,
        bankWalletId: bankWalletId || null,
        date: new Date(date),
        currency: currency || 'YER',
        exchangeRate: String(exchangeRate || '1'),
        totalAmount: String(totalAmount),
        reference: reference || null,
        createdBy: createdBy || null,
      }).returning();

      // Create operations
      for (const op of operations) {
        await tx.insert(paymentVoucherOperations).values({
          voucherId: voucher.id,
          accountType: op.accountType,
          accountSubtype: op.accountSubtype,
          chartAccountId: op.chartAccountId,
          analyticalAccountId: op.analyticalAccountId || null,
          amount: String(op.amount),
          description: op.description || null,
        });
      }

      // Update cash box balance
      if (cashBoxId) {
        const cashBox = await tx.select().from(cashBoxes).where(eq(cashBoxes.id, cashBoxId)).limit(1);
        if (cashBox.length > 0) {
          const currentBalance = parseFloat(cashBox[0].balance || '0');
          const amount = parseFloat(String(totalAmount));
          const newBalance = type === 'in' ? currentBalance + amount : currentBalance - amount;
          await tx.update(cashBoxes)
            .set({ balance: newBalance.toString(), updatedAt: new Date() })
            .where(eq(cashBoxes.id, cashBoxId));
        }
      }

      // Update bank/wallet balance
      if (bankWalletId) {
        const bankWallet = await tx.select().from(banksWallets).where(eq(banksWallets.id, bankWalletId)).limit(1);
        if (bankWallet.length > 0) {
          const currentBalance = parseFloat(bankWallet[0].balance || '0');
          const amount = parseFloat(String(totalAmount));
          const newBalance = type === 'in' ? currentBalance + amount : currentBalance - amount;
          await tx.update(banksWallets)
            .set({ balance: newBalance.toString(), updatedAt: new Date() })
            .where(eq(banksWallets.id, bankWalletId));
        }
      }

      newVoucher = voucher;
    });

    const result = await getVouchersWithRelations([newVoucher]);
    res.status(201).json(result[0]);
  } catch (error: any) {
    console.error('Error creating payment voucher:', error);
    res.status(500).json({ error: error.message || 'Failed to create payment voucher' });
  }
});

// Update payment voucher
router.put('/:id', async (req, res) => {
  try {
    const voucherId = req.params.id;
    const { date, currency, exchangeRate, totalAmount, reference, operations } = req.body;

    const existingVoucher = await db.select()
      .from(paymentVouchers)
      .where(eq(paymentVouchers.id, voucherId))
      .limit(1);

    if (existingVoucher.length === 0) {
      return res.status(404).json({ error: 'Payment voucher not found' });
    }

    await db.transaction(async (tx) => {
      if (date || currency || exchangeRate || totalAmount !== undefined || reference !== undefined) {
        await tx.update(paymentVouchers)
          .set({
            ...(date && { date: new Date(date) }),
            ...(currency && { currency }),
            ...(exchangeRate !== undefined && { exchangeRate: String(exchangeRate) }),
            ...(totalAmount !== undefined && { totalAmount: String(totalAmount) }),
            ...(reference !== undefined && { reference }),
            updatedAt: new Date(),
          })
          .where(eq(paymentVouchers.id, voucherId));
      }

      if (operations && Array.isArray(operations)) {
        await tx.delete(paymentVoucherOperations)
          .where(eq(paymentVoucherOperations.voucherId, voucherId));

        for (const op of operations) {
          await tx.insert(paymentVoucherOperations).values({
            voucherId,
            accountType: op.accountType,
            accountSubtype: op.accountSubtype,
            chartAccountId: op.chartAccountId,
            analyticalAccountId: op.analyticalAccountId || null,
            amount: String(op.amount),
            description: op.description || null,
          });
        }
      }
    });

    const voucher = await db.select().from(paymentVouchers).where(eq(paymentVouchers.id, voucherId)).limit(1);
    const result = await getVouchersWithRelations(voucher);
    res.json(result[0]);
  } catch (error: any) {
    console.error('Error updating payment voucher:', error);
    res.status(500).json({ error: error.message || 'Failed to update payment voucher' });
  }
});

// Delete payment voucher
router.delete('/:id', async (req, res) => {
  try {
    const voucherId = req.params.id;
    const voucher = await db.select().from(paymentVouchers).where(eq(paymentVouchers.id, voucherId)).limit(1);

    if (voucher.length === 0) {
      return res.status(404).json({ error: 'Payment voucher not found' });
    }

    await db.transaction(async (tx) => {
      // Reverse cash box balance
      if (voucher[0].cashBoxId) {
        const cashBox = await tx.select().from(cashBoxes).where(eq(cashBoxes.id, voucher[0].cashBoxId)).limit(1);
        if (cashBox.length > 0) {
          const currentBalance = parseFloat(cashBox[0].balance || '0');
          const amount = parseFloat(voucher[0].totalAmount);
          const newBalance = voucher[0].type === 'in' ? currentBalance - amount : currentBalance + amount;
          await tx.update(cashBoxes)
            .set({ balance: newBalance.toString(), updatedAt: new Date() })
            .where(eq(cashBoxes.id, voucher[0].cashBoxId));
        }
      }

      // Reverse bank/wallet balance
      if (voucher[0].bankWalletId) {
        const bankWallet = await tx.select().from(banksWallets).where(eq(banksWallets.id, voucher[0].bankWalletId)).limit(1);
        if (bankWallet.length > 0) {
          const currentBalance = parseFloat(bankWallet[0].balance || '0');
          const amount = parseFloat(voucher[0].totalAmount);
          const newBalance = voucher[0].type === 'in' ? currentBalance - amount : currentBalance + amount;
          await tx.update(banksWallets)
            .set({ balance: newBalance.toString(), updatedAt: new Date() })
            .where(eq(banksWallets.id, voucher[0].bankWalletId));
        }
      }

      // Delete voucher (operations cascade)
      await tx.delete(paymentVouchers).where(eq(paymentVouchers.id, voucherId));
    });

    res.status(204).send();
  } catch (error: any) {
    console.error('Error deleting payment voucher:', error);
    res.status(500).json({ error: error.message || 'Failed to delete payment voucher' });
  }
});

export default router;
